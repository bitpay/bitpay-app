diff --git a/node_modules/bitcore-tss/ecdsa/keygen.js b/node_modules/bitcore-tss/ecdsa/keygen.js
index cb9eccb..ce8ad2d 100644
--- a/node_modules/bitcore-tss/ecdsa/keygen.js
+++ b/node_modules/bitcore-tss/ecdsa/keygen.js
@@ -153,7 +153,7 @@ class KeyGen {
    * @param {Array<object>} prevRoundMessages 
    * @returns {{ round: number, partyId: number, publicKey: string, p2pMessages: object[], broadcastMessage: object[] }}
    */
-  nextRound(prevRoundMessages) {
+  async nextRound(prevRoundMessages) {
     $.checkState(this.#round > 0, 'initJoin must be called before participating in the rounds');
     $.checkState(this.#round < 5, 'Signing rounds are over');
     $.checkArgument(Array.isArray(prevRoundMessages), 'prevRoundMessages must be an array');
@@ -163,17 +163,40 @@ class KeyGen {
 
     const prevRoundIncomingMsgs = DklsComms.decryptAndVerifyIncomingMessages(prevRoundMessages, this.#authKey);
 
-    const thisRoundMessages = DklsTypes.serializeMessages(
-      this.#dkg.handleIncomingMessages(DklsTypes.deserializeMessages(prevRoundIncomingMsgs))
-    );
-
-    const signedMessage = DklsComms.encryptAndAuthOutgoingMessages(
-      thisRoundMessages,
-      prevRoundMessages.map(m => ({ partyId: m.partyId, publicKey: m.publicKey })),
-      this.#authKey
-    );
-
-    return this._formatMessage(signedMessage);
+    let deserializedMessages;
+    try {
+      deserializedMessages = DklsTypes.deserializeMessages(prevRoundIncomingMsgs);
+    } catch (deserializeError) {
+      throw deserializeError;
+    }
+
+    let incomingMessages;
+    try {
+      incomingMessages = await this.#dkg.handleIncomingMessages(deserializedMessages);
+    } catch (handleError) {
+      throw handleError;
+    }
+
+    let thisRoundMessages;
+    try {
+      thisRoundMessages = await DklsTypes.serializeMessages(incomingMessages);
+    } catch (serializeError) {
+      throw serializeError;
+    }
+
+    let signedMessage;
+    try {
+      signedMessage = DklsComms.encryptAndAuthOutgoingMessages(
+        thisRoundMessages,
+        prevRoundMessages.map(m => ({ partyId: m.partyId, publicKey: m.publicKey })),
+        this.#authKey
+      );
+    } catch (encryptError) {
+      throw encryptError;
+    }
+
+    const finalMessage = this._formatMessage(signedMessage);
+    return finalMessage;
   }
 
   /**
diff --git a/node_modules/bitcore-tss/ecdsa/sign.js b/node_modules/bitcore-tss/ecdsa/sign.js
index a7d48d1..72eb551 100644
--- a/node_modules/bitcore-tss/ecdsa/sign.js
+++ b/node_modules/bitcore-tss/ecdsa/sign.js
@@ -156,7 +156,6 @@ class Sign {
       [],
       this.#authKey
     );
-
     return this._formatMessage(signedMessage);
   }
 
@@ -166,23 +165,24 @@ class Sign {
    * @param {Array<Object>} prevRoundMessages 
    * @returns {{ round: number, partyId: number, publicKey: string, p2pMessages: Object[], broadcastMessages: Object[] }}
    */
-  nextRound(prevRoundMessages) {
+  async nextRound(prevRoundMessages) {
     $.checkState(this.#round > 0, 'initJoin must be called before participating in the rounds');
     $.checkState(this.#round < 5, 'Signing rounds are over');
     $.checkArgument(Array.isArray(prevRoundMessages), 'prevRoundMessages must be an array');
     $.checkArgument(prevRoundMessages.length === this.#minSigners - 1, 'Not ready to proceed to the next round');
     $.checkArgument(prevRoundMessages.every(msg => msg.round === this.#round - 1), 'All messages must be from the previous round');
-    $.checkArgument(prevRoundMessages.every(msg => msg.partyId !== this.#partyId), 'Messages must not be from the yourself');
-
-    let prevRndMsg = DklsComms.decryptAndVerifyIncomingMessages(prevRoundMessages, this.#authKey);
-    prevRndMsg = DklsTypes.deserializeMessages(prevRndMsg);
-
-    const thisRoundMsg = this.#dsg.handleIncomingMessages(prevRndMsg);
-    const thisRoundMessage = DklsTypes.serializeMessages(thisRoundMsg);
-
-    const partyPubKeys = prevRoundMessages.map(m => ({ partyId: m.partyId, publicKey: m.publicKey }));
+    $.checkArgument(prevRoundMessages.every(msg => msg.partyId !== this.#partyId), 'Messages must not be from yourself');
+    
+    const prevRndMsg = DklsComms.decryptAndVerifyIncomingMessages(prevRoundMessages, this.#authKey);
+    const deserializedMessages = DklsTypes.deserializeMessages(prevRndMsg);
+    const incomingMessages = await this.#dsg.handleIncomingMessages(deserializedMessages);
+    const thisRoundMessages = await DklsTypes.serializeMessages(incomingMessages);
+    const partyPubKeys = prevRoundMessages.map(m => ({ 
+      partyId: m.partyId, 
+      publicKey: m.publicKey 
+    }));
     const signedMessage = DklsComms.encryptAndAuthOutgoingMessages(
-      thisRoundMessage,
+      thisRoundMessages,
       partyPubKeys,
       this.#authKey
     );
diff --git a/node_modules/bitcore-tss/ecies/ecies.js b/node_modules/bitcore-tss/ecies/ecies.js
index 120b696..346e386 100644
--- a/node_modules/bitcore-tss/ecies/ecies.js
+++ b/node_modules/bitcore-tss/ecies/ecies.js
@@ -16,10 +16,11 @@ function KDF(privateKey, publicKey) {
   const KB = publicKey.point;
   const P = KB.mul(r);
   const S = P.getX();
-  const Sbuf = S.toBuffer({ size: 32 });
-  const kEkM = Hash.sha512(Sbuf);
-  const kE = kEkM.subarray(0, 32);
-  const kM = kEkM.subarray(32, 64);
+  const Sbuf = Buffer.from(S.toBuffer({ size: 32 }));    
+  const kEkM = Buffer.from(Hash.sha512(Sbuf)); 
+   // In RN, subarray may return Uint8Array; force real Buffers:
+   const kE = Buffer.from(kEkM.subarray(0, 32));
+   const kM = Buffer.from(kEkM.subarray(32, 64));
   return [kE, kM];
 };
 
@@ -127,13 +128,13 @@ function decrypt({ payload, privateKey, publicKey, opts = {} }) {
     offset += pub.length;
   }
 
-  const ivbuf = payload.subarray(offset, offset + 16);
-  const cipherText = payload.subarray(offset + 16, payload.length - tagLength);
-  const tag = payload.subarray(payload.length - tagLength, payload.length);
+  const ivbuf = Buffer.from(payload.subarray(offset, offset + 16));
+  const cipherText = Buffer.from(payload.subarray(offset + 16, payload.length - tagLength));
+  const tag = Buffer.from(payload.subarray(payload.length - tagLength, payload.length));
 
   const [kE, kM] = KDF(privateKey, publicKey);
 
-  const tag2 = Hash.sha256hmac(cipherText, kM).subarray(0, tagLength);
+  const tag2 = Buffer.from(Hash.sha256hmac(cipherText, kM)).slice(0, tagLength);
   if (tag2.compare(tag) !== 0) {
     throw new Error('Invalid checksum');
   }
