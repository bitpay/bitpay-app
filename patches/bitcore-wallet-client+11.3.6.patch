diff --git a/node_modules/bitcore-wallet-client/ts_build/src/lib/api.js b/node_modules/bitcore-wallet-client/ts_build/src/lib/api.js
index ca96d75..1ab4ef8 100644
--- a/node_modules/bitcore-wallet-client/ts_build/src/lib/api.js
+++ b/node_modules/bitcore-wallet-client/ts_build/src/lib/api.js
@@ -49,6 +49,7 @@ const common_1 = require("./common");
 const credentials_1 = require("./credentials");
 const errors_1 = require("./errors");
 const key_1 = require("./key");
+const tsskey_1 = require("./tsskey");
 const log_1 = __importDefault(require("./log"));
 const paypro_1 = require("./paypro");
 const payproV2_1 = require("./payproV2");
@@ -799,6 +800,7 @@ class API extends events_1.EventEmitter {
             };
             const { body: res } = await this.request.post('/v2/wallets/', args);
             const walletId = res.walletId;
+ 
             c.addWalletInfo(walletId, walletName, m, n, copayerName, {
                 useNativeSegwit: opts.useNativeSegwit,
                 segwitVersion: opts.segwitVersion,
@@ -2821,6 +2823,7 @@ exports.API = API;
 API.PayProV2 = payproV2_1.PayProV2;
 API.PayPro = paypro_1.PayPro;
 API.Key = key_1.Key;
+API.TssKey = tsskey_1.TssKey;
 API.Verifier = verifier_1.Verifier;
 API.Core = CWC;
 API.Utils = common_1.Utils;
diff --git a/node_modules/bitcore-wallet-client/ts_build/src/lib/common/encryption.js b/node_modules/bitcore-wallet-client/ts_build/src/lib/common/encryption.js
index ffb28f7..9193a78 100644
--- a/node_modules/bitcore-wallet-client/ts_build/src/lib/common/encryption.js
+++ b/node_modules/bitcore-wallet-client/ts_build/src/lib/common/encryption.js
@@ -7,10 +7,18 @@ exports.Encryption = void 0;
 const crypto_1 = __importDefault(require("crypto"));
 const PBKDF2_ITERATIONS = 1000;
 const DEFAULT_KEY_SIZE = 256;
-const ALGORITHM = ks => `aes-${ks || DEFAULT_KEY_SIZE}-ccm`;
+const ALGORITHM = ks => `aes-${ks || DEFAULT_KEY_SIZE}-gcm`;
 const AUTH_TAG_LENGTH = 16;
 const SALT_LENGTH = 16;
-const MAX_IV_LENGTH = 13;
+const IV_LENGTH = 12;
+const toBuf = (x) => {
+    if (Buffer.isBuffer(x)) return x;
+    if (x instanceof Uint8Array) return Buffer.from(x);
+    if (x instanceof ArrayBuffer) return Buffer.from(new Uint8Array(x));
+    if (x == null) return Buffer.alloc(0);
+    return Buffer.from(String(x));
+  };
+
 class EncryptionClass {
     _optimizeIv(length, iv) {
         let L = 2;
@@ -25,18 +33,18 @@ class EncryptionClass {
     }
     _baseEncrypt(data, key) {
         const buf = Buffer.isBuffer(data) ? data : Buffer.from(typeof data === 'string' ? data : JSON.stringify(data), 'utf8');
-        const iv = this._optimizeIv(buf.length, crypto_1.default.randomBytes(MAX_IV_LENGTH));
-        const cipher = crypto_1.default.createCipheriv(ALGORITHM(key.length * 8), key, iv, { authTagLength: AUTH_TAG_LENGTH, plaintextLength: buf.length });
-        let encrypted = cipher.update(buf);
-        encrypted = Buffer.concat([encrypted, cipher.final()]);
+        const iv = crypto_1.default.randomBytes(IV_LENGTH);
+        const cipher = crypto_1.default.createCipheriv(ALGORITHM(key.length * 8), key, iv, { authTagLength: AUTH_TAG_LENGTH });
+        let encrypted = toBuf(cipher.update(buf));
+        encrypted = Buffer.concat([encrypted, toBuf(cipher.final())]);
         return {
             iv: iv.toString('base64'),
             v: 1,
             ts: AUTH_TAG_LENGTH * 8,
-            mode: 'ccm',
+            mode: 'gcm',
             adata: '',
             cipher: 'aes',
-            ct: Buffer.concat([encrypted, cipher.getAuthTag()]).toString('base64')
+            ct: Buffer.concat([encrypted, toBuf(cipher.getAuthTag())]).toString('base64')
         };
     }
     encryptWithKey(data, key) {
diff --git a/node_modules/bitcore-wallet-client/ts_build/src/lib/credentials.js b/node_modules/bitcore-wallet-client/ts_build/src/lib/credentials.js
index c076dcd..c792064 100644
--- a/node_modules/bitcore-wallet-client/ts_build/src/lib/credentials.js
+++ b/node_modules/bitcore-wallet-client/ts_build/src/lib/credentials.js
@@ -48,7 +48,7 @@ class Credentials {
         const entropySource = crypto_wallet_core_1.BitcoreLib.crypto.Hash.sha256(priv.toBuffer()).toString('hex');
         const b = Buffer.from(entropySource, 'hex');
         const b2 = crypto_wallet_core_1.BitcoreLib.crypto.Hash.sha256hmac(b, Buffer.from(prefix));
-        x.personalEncryptingKey = b2.subarray(0, 16).toString('base64');
+        x.personalEncryptingKey = Buffer.from(b2.subarray(0, 16)).toString('base64');
         x.copayerId = common_1.Utils.xPubToCopayerId(x.chain, x.xPubKey);
         x.publicKeyRing = [
             {
diff --git a/node_modules/bitcore-wallet-client/ts_build/src/lib/key.js b/node_modules/bitcore-wallet-client/ts_build/src/lib/key.js
index 1fa419a..95acbb7 100644
--- a/node_modules/bitcore-wallet-client/ts_build/src/lib/key.js
+++ b/node_modules/bitcore-wallet-client/ts_build/src/lib/key.js
@@ -95,6 +95,7 @@ class Key {
         this.use44forMultisig = opts.useLegacyPurpose;
         this.compliantDerivation = !opts.nonCompliantDerivation;
         let x = opts.seedData;
+
         switch (opts.seedType) {
             case 'new':
                 if (opts.language && !wordsForLang[opts.language])
diff --git a/node_modules/bitcore-wallet-client/ts_build/src/lib/tsssign.js b/node_modules/bitcore-wallet-client/ts_build/src/lib/tsssign.js
index f0e05d8..570e212 100644
--- a/node_modules/bitcore-wallet-client/ts_build/src/lib/tsssign.js
+++ b/node_modules/bitcore-wallet-client/ts_build/src/lib/tsssign.js
@@ -50,7 +50,12 @@ class TssSign extends events_1.EventEmitter {
         $.checkArgument(!messageHash || Buffer.isBuffer(messageHash), 'messageHash must be a Buffer');
         $.checkArgument(!message || Buffer.isBuffer(message) || typeof message === 'string', 'message must be a string or Buffer');
         $.checkArgument(id == null || typeof id === 'string', 'id must be a string or not provided');
-        $.checkArgument(password || __classPrivateFieldGet(this, _TssSign_tssKey, "f").keychain.privateKeyShare, 'password is required to decrypt the TSS private key share');
+        
+        $.checkArgument(
+            __classPrivateFieldGet(this, _TssSign_tssKey, "f").keychain.privateKeyShare, 
+            'Key shares are required for signing. Make sure backupKeyShare was enabled during key generation.'
+        );
+        
         if (!messageHash && typeof message === 'string') {
             if (encoding === 'hex') {
                 message = message.startsWith('0x') ? message.slice(2) : message;
@@ -58,8 +63,12 @@ class TssSign extends events_1.EventEmitter {
             message = Buffer.from(message, encoding);
             messageHash = crypto_wallet_core_1.BitcoreLib.crypto.Hash.sha256(message);
         }
+        
+        const keychain = __classPrivateFieldGet(this, _TssSign_tssKey, "f").get(password).keychain
+        if( keychain.privateKeyShare.data )keychain.privateKeyShare = Buffer.from(keychain.privateKeyShare.data);
+
         __classPrivateFieldSet(this, _TssSign_sign, new bitcore_tss_1.ECDSA.Sign({
-            keychain: __classPrivateFieldGet(this, _TssSign_tssKey, "f").get(password).keychain,
+            keychain:keychain,
             partyId: __classPrivateFieldGet(this, _TssSign_tssKey, "f").metadata.partyId,
             m: __classPrivateFieldGet(this, _TssSign_tssKey, "f").metadata.m,
             n: __classPrivateFieldGet(this, _TssSign_tssKey, "f").metadata.n,
@@ -67,10 +76,12 @@ class TssSign extends events_1.EventEmitter {
             messageHash,
             authKey: __classPrivateFieldGet(this, _TssSign_credentials, "f").requestPrivKey
         }), "f");
+        
         this.id = id || crypto_wallet_core_1.BitcoreLib.crypto.Hash.sha256(messageHash).toString('hex');
         const msg = await __classPrivateFieldGet(this, _TssSign_sign, "f").initJoin();
         const m = __classPrivateFieldGet(this, _TssSign_tssKey, "f").metadata.m;
         await __classPrivateFieldGet(this, _TssSign_request, "f").post('/v1/tss/sign/' + this.id, { message: msg, m });
+        
         return this;
     }
     exportSession() {
@@ -83,9 +94,11 @@ class TssSign extends events_1.EventEmitter {
         const { session } = params;
         const [id, sigSession] = session.split(':');
         this.id = id;
+        const keychain = __classPrivateFieldGet(this, _TssSign_tssKey, "f").keychain
+        if( keychain.privateKeyShare.data )keychain.privateKeyShare = Buffer.from(keychain.privateKeyShare.data);
         __classPrivateFieldSet(this, _TssSign_sign, await bitcore_tss_1.ECDSA.Sign.restore({
             session: sigSession,
-            keychain: __classPrivateFieldGet(this, _TssSign_tssKey, "f").keychain,
+            keychain: keychain,
             authKey: __classPrivateFieldGet(this, _TssSign_credentials, "f").requestPrivKey
         }), "f");
         return this;
